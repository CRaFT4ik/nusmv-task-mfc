MODULE main

VAR 
    state: array 0..0 of {SORTED, NOT_SORTED};
    arr: array 0..M of 0..K;
    i: 0..(M - 1);
    j: 0..(M - 1);
    swap_tmp: array 0..1 of 0..K;

DEFINE
    M := 5; -- размер массива
    K := 10; -- значения массива 0..K

    need_swap := swap_tmp[0] > swap_tmp[1]; -- arr[j] > arr[j + 1];
    complete := (i = M - 1);

ASSIGN
    init(i) := 0;
    init(j) := 0;
    init(swap_tmp[0]) := arr[j];
    init(swap_tmp[1]) := arr[j + 1];
    init(state[0]) := NOT_SORTED;

    init(arr[0]) := 4;
    init(arr[1]) := 2;
    init(arr[2]) := 3;
    init(arr[3]) := 1;
    init(arr[4]) := 5;
    init(arr[5]) := 6;

    next(swap_tmp[0]) := case
        state[0] = NOT_SORTED: arr[j];
        TRUE: swap_tmp[0];
    esac;

    next(swap_tmp[1]) := case
        state[0] = NOT_SORTED: arr[j + 1];
        TRUE: swap_tmp[1];
    esac;

    next(j) := case
        j = (M - 1): 0;
        TRUE: j + 1;
    esac;

    next(i) := case
        i = (M - 1): i;
        j = (M - 1): i + 1;
        TRUE: i;
    esac;

    next(state[0]) := case
        complete: SORTED;
        TRUE: NOT_SORTED;
    esac;

TRANS
    need_swap -> (
        next(arr[j]) = swap_tmp[1] &
        next(arr[j + 1]) = swap_tmp[0]
    );

TRANS
    complete -> (
        next(arr[j]) = arr[j] &
        next(arr[j + 1]) = arr[j + 1]
    );



-- There exists no path in which the algorithm ends
LTLSPEC ! F complete

-- There exists no path in which the algorithm ends
-- with a sorted array
LTLSPEC ! F G (arr[0] <= arr[1] &
               arr[1] <= arr[2] &
               arr[2] <= arr[3] &
               arr[3] <= arr[4] &
               arr[4] <= arr[5] &
               complete)